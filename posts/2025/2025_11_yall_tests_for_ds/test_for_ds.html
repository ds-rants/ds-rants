<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="DS Rants">
<meta name="dcterms.date" content="2025-11-20">

<title>Y’all Motherfuckers Need Tests, So Stop Making Lazy Excuses – Data Science Rants</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-5d4073339ea55b1ad5ce071f10a273ff.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-9433ce5a74f539ffa23693f38c94ac7f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Science Rants</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Y’all Motherfuckers Need Tests, So Stop Making Lazy Excuses</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">data science</div>
                <div class="quarto-category">software engineering</div>
                <div class="quarto-category">tests</div>
                <div class="quarto-category">best practices</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>DS Rants </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 20, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-specific-problems-with-testing-in-data-science" id="toc-the-specific-problems-with-testing-in-data-science" class="nav-link active" data-scroll-target="#the-specific-problems-with-testing-in-data-science">The Specific Problems With Testing In Data Science</a>
  <ul class="collapse">
  <li><a href="#the-hidden-forms-of-couplings" id="toc-the-hidden-forms-of-couplings" class="nav-link" data-scroll-target="#the-hidden-forms-of-couplings">The Hidden Forms Of Couplings</a></li>
  <li><a href="#issues-with-dataframe-like-testing-and-remediation-strategies" id="toc-issues-with-dataframe-like-testing-and-remediation-strategies" class="nav-link" data-scroll-target="#issues-with-dataframe-like-testing-and-remediation-strategies">Issues With Dataframe-Like Testing And Remediation Strategies</a></li>
  <li><a href="#simple-advice-for-writing-dataframe-tests" id="toc-simple-advice-for-writing-dataframe-tests" class="nav-link" data-scroll-target="#simple-advice-for-writing-dataframe-tests">Simple Advice For Writing DataFrame Tests</a></li>
  </ul></li>
  <li><a href="#testing-at-larger-scale" id="toc-testing-at-larger-scale" class="nav-link" data-scroll-target="#testing-at-larger-scale">Testing At Larger Scale</a>
  <ul class="collapse">
  <li><a href="#what-about-integration-testing" id="toc-what-about-integration-testing" class="nav-link" data-scroll-target="#what-about-integration-testing">What About Integration Testing?</a></li>
  <li><a href="#acceptance-testing-in-the-data-world-a.k.a-evaluation" id="toc-acceptance-testing-in-the-data-world-a.k.a-evaluation" class="nav-link" data-scroll-target="#acceptance-testing-in-the-data-world-a.k.a-evaluation">Acceptance Testing In The Data World a.k.a Evaluation?</a></li>
  <li><a href="#the-holy-grail-of-data-tests" id="toc-the-holy-grail-of-data-tests" class="nav-link" data-scroll-target="#the-holy-grail-of-data-tests">The Holy Grail Of Data Tests</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>This is the second part of a larger rant on tests with the first part available <a href="../../../posts/2025/2025_11_yall_motherfuckers_need_tests/index.html">here</a>.</p>
<p>In the first part, I mainly addressed the canonical definitions of testing, the typical difficulties that arise, and potential strategies to progressively get better at testing. By now, with the bold assumption that you possess a shred of common sense (and survival instinct), you should at least feel strongly that testing in data science should have much greater importance, to say the least.</p>
<p>But sadly, there’ll always be some junkie data scientists snorting LinkedIn posts and drunk on Jeff Bezos’ apocryphal success stories, who will tell you how special their work is, how testing doesn’t work for them, and how it would only slow them down. Despite my strong desire to caress the frontal lobe of such a person with a shovel, vaporize them on the spot, and curse all their family branches for the next 13 generations, I’ll momentarily refrain from violence.</p>
<p>Instead, I’ll try to address some reasonable objections one could raise regarding the quirks and specificities that make testing in the data world trickier. But don’t mistake this moment of kindness for any form of weakness; at the end, you’ll have no excuses left.</p>
<section id="the-specific-problems-with-testing-in-data-science" class="level2">
<h2 class="anchored" data-anchor-id="the-specific-problems-with-testing-in-data-science">The Specific Problems With Testing In Data Science</h2>
<p>As mentioned previously for those sleeping in the back of the classroom, data scientists largely deal with large amounts of… data. This means the first action is typically to pull something from a database (lucky you), read a decently structured CSV (we all have to eat), a manually filled Excel file (fly, you fools!), or something far worse—and believe me, you don’t want to know. Do you remember what I said about testing—let alone TDD—being difficult with I/O and external coupling?</p>
<section id="the-hidden-forms-of-couplings" class="level3">
<h3 class="anchored" data-anchor-id="the-hidden-forms-of-couplings">The Hidden Forms Of Couplings</h3>
<p>In addition, the testing process is particularly difficult because most of the objects we deal with are collections of items, usually quite complex. Now add a sprinkle of types and object structures which are usually looser than your own mother’s morals. On top of that, these items are usually independent only in the best-case scenarios but most likely related to each other in some nasty way. How many times have you had to do an analysis in which one record at a given time strongly influenced what was to be done on surrounding elements, but only until variable B changed to a different value?</p>
<p>You don’t believe me? Let’s assume, for ungodly reasons, that you can only use 50% of your dataset for training your model: are you keeping the latest 50%, the oldest, or randomly discarding data? Sure, we can set aside this scenario, which is as plausible as Mark Zuckerberg giving a rat’s ass about your privacy or the people he fired. But I cannot recall, since I started working in the industry, a single real-life dataset in which time played no role at all in some weird way or with disguised influence (say goodbye to your Kaggle/tutorial static datasets).</p>
<p>These questions can remain somewhat secondary in the pure ‘developer’ world. Indeed, as long as the objects themselves remain valid and the code processing them remains correct, the system works properly. This is a strong yet hidden form of coupling that is difficult to circumvent in automated tests but is a major concern for any data science workflow.</p>
<p>And it has only just begun…</p>
</section>
<section id="issues-with-dataframe-like-testing-and-remediation-strategies" class="level3">
<h3 class="anchored" data-anchor-id="issues-with-dataframe-like-testing-and-remediation-strategies">Issues With Dataframe-Like Testing And Remediation Strategies</h3>
<p>For a data scientist, writing meaningful unit tests may require a decent amount of boilerplate even for simple data and light transformations. This assumes processing done largely on some kind of dataframe/array (which will encompass 95% of <code>pandas</code> and <code>numpy</code> junkies).</p>
<p>I will assume you have a shred of decency for your coworkers, meaning your transformations look like this:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>daily_awesome_calculations <span class="op">=</span> (</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    original_record_with_meaningful_name</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">drop_nulls</span>()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">filter</span>(<span class="op">...</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">group_by</span>(<span class="st">"day"</span><span class="op">,</span> <span class="st">"categorical_variable_B"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">agg</span>(<span class="op">...</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">sort</span>()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>If not, please go see <a href="../../../posts/2025/2025_04_13_your_pandas_code_is_bad/index.html">here</a> and <a href="../../../posts/2025/2025_04_28_angry_pandas_guide/angry_pandas_tutorial.html">there</a>. In the absence of any improvement on this matter, I will eagerly greet you with a shovel, as mentioned earlier. You have been warned…</p>
<p>Here, with the use of <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> (Domain-specific Language) like <code>pandas</code>/<code>polars</code>/<code>numpy</code>, it can be tricky to determine if you are actually testing <strong>your custom</strong> logic or retesting the methods of a library that are already (hopefully) battle-tested.</p>
<p>For a dataframe test that is not excruciating to write, one needs to strip away all surrounding complexity. This requires the ability to use the smallest number of rows and columns. A good rule of thumb is usually 2-Rows * x-Columns or 3-Rows * x-Columns to get you started. If you can manage with only one row, you should!</p>
<p>Regardless, here are some general pointers:</p>
</section>
<section id="simple-advice-for-writing-dataframe-tests" class="level3">
<h3 class="anchored" data-anchor-id="simple-advice-for-writing-dataframe-tests">Simple Advice For Writing DataFrame Tests</h3>
<ol type="1">
<li><p>Separate DataFrame and pure Python logic as much as you can. Generally speaking, mixing pandas and Python is a sure-fire way to make your code slow and, in most cases, false. Additionally, Python logic is much easier to perform unit tests on.</p></li>
<li><p>Unit testing on DataFrames is still possible with very small examples. Keep things as simple as you can with very small data subsets, here again, shapes of 2-Rows * x-Columns or 3-Rows * x-Columns or even smaller are your best friends. Your favorite LLM overlord can help you with the first draft of the boilerplate. Once you have the general structure, it can usually be reused on multiple tests.</p></li>
<li><p>Make the data inside the example dataframe as plain, idiotic and stupid simple as possible. You should aim for the average cryptobro level here, especially during test setup or ‘given’ stage. This will likely decrease the coupling with your implementation code. It will also increase the maintainability of your test in the long run.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>given <span class="op">=</span> pd.DataFrame(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"station"</span>: [<span class="st">"a"</span>, <span class="st">"b"</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>         <span class="st">"temperature_in_celsius"</span>: [<span class="fl">1.1</span>, <span class="fl">2.3</span>],</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>     }</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a> )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>is better than:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>given <span class="op">=</span> pd.DataFrame(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>     {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"station"</span>: [<span class="st">"NZ_EXT_1"</span>, <span class="st">"DE_INT_42"</span>],</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>         <span class="st">"temperature_in_celsius"</span>: [<span class="fl">1.132554</span>, <span class="fl">2.3738687</span>],</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>     }</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p>Testing on DataFrames requires more skill and time to get used to than non-data science code. Again, practice testing on pure Python first before jumping straight into the ocean of complexity. Similarly, practice on things with a smaller scope at first.</p></li>
<li><p>Be wary of the scope: with too many steps and too much logic, you might have to make your tests extremely permissive. For example, just checking that you have more rows in your DataFrame after 30 transformations is unlikely to be highly informative…</p></li>
</ol>
<p>Again, combining those ideas requires a fairly decent bit of expertise to determine the seams/separations in your code to make testing easier.</p>
</section>
</section>
<section id="testing-at-larger-scale" class="level2">
<h2 class="anchored" data-anchor-id="testing-at-larger-scale">Testing At Larger Scale</h2>
<p>There is a sort of opposition between scale and the ease of applying TDD principles. Indeed, the cornerstone of a good testing strategy is <strong>to obtain a fast, reliable, and deterministic feedback</strong> that allows the developer to have confidence that the proposed changes are safe to release. Accounting for all use cases in the integration and acceptance steps would make the testing unnecessarily slow, bulky, and probably as useful as a statement from Sam Altman on AGI.</p>
<section id="what-about-integration-testing" class="level3">
<h3 class="anchored" data-anchor-id="what-about-integration-testing">What About Integration Testing?</h3>
<p>The role of integration testing is to make sure that the sub-components and modules of your system work properly and fit together to produce some expected behavior.</p>
<p>In the Data Land, integration tests can usually be done by taking a larger chunk of your datasets (plural, because have you ever seen a project with just one…). For example, in Machine Learning workflows, you can try to pass the smallest possible amount of data through your preprocessing, then assert that you indeed got rid of certain columns and managed to remove nulls in certain others.</p>
<p>You can then continue passing this small sample through your training and at least make sure that the training can start. There is a tremendous difference between fully automating this and using a pseudo-manual verification (either inside a notebook or via a CLI that you might forget to type).</p>
<p>Again, the point here is to ensure that preprocessing, training, evaluation, and similar components can feed into each other. We are not talking about model performance or hyper-parameter tuning.</p>
</section>
<section id="acceptance-testing-in-the-data-world-a.k.a-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="acceptance-testing-in-the-data-world-a.k.a-evaluation">Acceptance Testing In The Data World a.k.a Evaluation?</h3>
<p>Traditionally, acceptance tests are designed to verify the bare-minimum working state of your system, again, by validating the critical or major hot paths within your application. Similarly, they also tend to appear later in the life of IT projects, once the scope becomes clearer.</p>
<p>With them, you should be able to obtain a definitive answer to the question: “Is my system in a working state so that it can be deployed?” In that regard, data science systems make no exception. This is where you’ll be able to plug in your database, buckets, and APIs.</p>
<p>In ML workflows, the automated evaluation of a model’s performance and its comparison with a previously deployed model can usually be a good approach for acceptance testing. However, the scope of this question is so large that tons of books have been written on the subject, and sadly, this blog has very little to offer in comparison (especially on the politically correct side of things…). The final strategy will vary greatly depending on the size of your data, the necessary retraining frequency, the selected metrics, and the type of model considered. The main point remains: automate this as much as you can!</p>
</section>
<section id="the-holy-grail-of-data-tests" class="level3">
<h3 class="anchored" data-anchor-id="the-holy-grail-of-data-tests">The Holy Grail Of Data Tests</h3>
<p>Data tests, also called defensive testing, are here to validate… the data! They stand in a weird position because we mainly see them at the level of the whole data pipeline, although they can fit at many levels of the testing pyramid. These tests ensure that you actually have a primary key (unique <strong>and</strong> non-null for the sleepy ones), that numeric columns fit within a certain range, and that you got rid of nulls…</p>
<p>This is where <code>dbt</code>, <code>dataform</code>, <code>SQLMesh</code>, and similar SQL-based frameworks really shine by allowing you to test data at a large scale. Using such frameworks, it is still possible to write code using TDD. Simply put, rather than starting to write SQL code, you will start by specifying in the metadata the types and tests for a given column. They are obviously SQL-oriented, but their contribution to our field is really a game changer.</p>
<p>In Python, few packages have been developed to help you use a TDD workflow in data science. One issue is perhaps that they tend to be quite different from the DSL you are working with (while Kent Beck says that a testing framework should be in the same language as the code for TDD). Another problem is that none of them have managed to obtain the same reach and influence as the SQL-based ones, with the notable exceptions of <code>great-expectations</code> (which can be a little quirky and slow to use) and the great <code>pydantic</code> (more oriented for APIs). The catch, again, is that they are not necessarily fitted for TDD in Data Science.</p>
<p>Other defensive analysis packages for <code>pandas</code>, such as <code>engarde</code> or <code>bulwark</code>, receive less maintenance than your great-great-great-grandparent’s tomb. They also have a MAJOR design flaw, because someone thought it would be a good idea to promote a decorator-oriented approach. Clearly, simple designs are for weak-minded people. Similarly, type hints, which have been around since 2015, have been carefully omitted to ensure that after one step my IDE has no fucking idea of the object type it is currently dealing with. That is, again, not ideal for TDD.</p>
<p>On the <code>polars</code> side, there is one obscure package called <code>pelage</code>, providing fairly similar functionality to dbt tests. Thanks to a total absence of marketing, the level of adoption is currently on par with the number of working brain cells of the average Elon Musk fanboy…</p>
<p>In the end, if you have the possibility to jam as many tests as you can within your SQL pipelines, please, knock yourself out! Worst-case scenario, your analytics tables might end up with an actual working primary key, which would be a nice change for once… just saying… And who knows, you could accidentally end up with a dashboard in which the numbers are not just straight-up lies or a rough estimate, but are actually accurate…</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This glorious landscape—made of lying dashboards, misleading analyses, and an astonishing 80-90% of machine learning projects that die without reaching production—is just a clear sign that our profession still lacks discipline. We need to incorporate better practices into our work. It may take many different forms, but I am sure that testing will and should be a part of it.</p>
<p>Certainly, there are specific issues with data science that make it more difficult to test. Granted, you might not know if you are going to keep that freshly made 500-line analysis. But let’s be real for a minute: the fact that your 500 lines haven’t been tested is probably a good reason why it will end up down the drain. The main reason you are probably not testing is that you have no idea how to do it on anything beyond FizzBuzz, let alone in a TDD workflow. Testing in Data Science is hard, but do not kid yourself: it is doable and should be done. If anything, the specific hardships of Data Science should make us yearn for already-proven solutions that increase software reliability and decrease our cognitive burden. But I guess some people like their legacy projects served early in the morning with entire chunks of burnout in them.</p>
<p>Clearly, the “Dev” culture has not yet been imported into the Data Science world, and most of us definitely missed the DevOps train. Yet, people who have jumped on it are out there. They deploy 5 times a day to production, use canary releases after training 10 models concurrently on perfect copies of their prod environment, after a simple commit-push. None of these steps can be reached without strict automated testing or a strong self-discipline, such as not touching production with greasy data scientist fingers. We should strive for better quality standards if we ever want to be considered <strong>serious software engineers</strong>.</p>
<p>In the end, mastery is what we need. With this demonstration, I hope you are now as absolutely convinced as I am of the imperious necessity of importing good testing strategies into Data Science. Otherwise, it’s better if you and I never find ourselves in the same room, because I will definitely reach for that shovel.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/ds-rants\.github\.io\/ds-rants\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>